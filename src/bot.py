import os
from dotenv import load_dotenv

from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, MessageHandler,
    ContextTypes, ConversationHandler, filters, CallbackQueryHandler
)
import pandas as pd

load_dotenv()
TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")

# –ó–∞–≥—Ä—É–∂–∞–µ–º Excel-—Ñ–∞–π–ª –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
df = pd.read_excel(r'C:\Users\user\PycharmProjects\telegram_excel_sorter\data\–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ.xlsx')

# –ü—É—Ç—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∑–∞–º–µ—Ç–æ–∫
NOTES_FILE = 'notes.csv'

# –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ —Ñ–∞–π–ª –¥–ª—è –∑–∞–º–µ—Ç–æ–∫ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
if not os.path.exists(NOTES_FILE):
    pd.DataFrame(columns=["User", "Keywords", "UniqueID", "Magazin", "Note"]).to_csv(NOTES_FILE, index=False)

# –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è ConversationHandler
SEARCH, CHOOSE_RESULT, NOTE, DELETE_NOTE = range(4)


# –ö–æ–º–∞–Ω–¥–∞ /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ —Ç–∞–±–ª–∏—Ü–µ üìä\n"
        "–í–≤–µ–¥–∏—Ç–µ —Å–ª–æ–≤–æ –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤ —Ç–∞–±–ª–∏—Ü–µ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /view_notes –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∑–∞–º–µ—Ç–æ–∫."
    )
    return SEARCH


# –ö–æ–º–∞–Ω–¥–∞ /view_notes
async def view_notes(update: Update, context: ContextTypes.DEFAULT_TYPE):
    notes_df = pd.read_csv(NOTES_FILE)
    if notes_df.empty:
        await update.message.reply_text("üìã –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∑–∞–º–µ—Ç–æ–∫.")
        return

    response_text = "üìã –í–∞—à–∏ –∑–∞–º–µ—Ç–∫–∏:\n"
    for idx, note_row in notes_df.iterrows():
        response_text += (
            f"{idx + 1}. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {note_row['User']}\n"
            f"–ú–∞–≥–∞–∑–∏–Ω: {note_row['Magazin']}\n"
            f"–ó–∞–º–µ—Ç–∫–∞: {note_row['Note']}\n\n"
        )

    await update.message.reply_text(response_text)


# –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –ø–æ–∏—Å–∫–∞
def format_search_result(index, result, related_notes):
    result_text = (
        f"üîç –†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ–∏—Å–∫–∞: {index + 1}\n\n"
        f"–ö–æ–¥: {result.get('–ö–æ–¥', '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö')}\n"
        f"–ú–∞–≥–∞–∑–∏–Ω: {result.get('–ú–∞–≥–∞–∑–∏–Ω', '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö')}\n"
        f"–¢–∏–ø: {result.get('–¢–∏–ø', '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö')}\n"
        f"–§–ò–û —Å–∏—Å—Ç–µ–º–æ—Ç–µ—Ö–Ω–∏–∫–∞: {result.get('–§–ò–û —Å–∏—Å—Ç–µ–º–æ—Ç–µ—Ö–Ω–∏–∫–∞', '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö')}\n"
        f"–ê–¥—Ä–µ—Å: {result.get('–ê–¥—Ä–µ—Å', '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö')}\n"
        f"–ü–æ–ª–Ω—ã–π –∞–¥—Ä–µ—Å: {result.get('–ü–æ–ª–Ω—ã–π –∞–¥—Ä–µ—Å', '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö')}\n\n"
    )
    # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–º–µ—Ç–∫–∏, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
    result_text += "üìå –ó–∞–º–µ—Ç–∫–∏:\n"
    if related_notes.empty:
        result_text += "-\n"
    else:
        for local_index, note_row in enumerate(related_notes.itertuples(), start=1):
            result_text += f"{local_index}. {note_row.Note}\n"
    return result_text


# –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–∏—Å–∫–∞
async def handle_search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyword = update.message.text.lower()
    context.user_data['last_keyword'] = keyword

    # –ü–æ–∏—Å–∫ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º —Ñ–∞–π–ª–µ
    result = df[df.apply(lambda row: row.astype(str).str.lower().str.contains(keyword).any(), axis=1)]

    # –ó–∞–≥—Ä—É–∂–∞–µ–º –∑–∞–º–µ—Ç–∫–∏ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞
    notes_df = pd.read_csv(NOTES_FILE)

    if result.empty:
        await update.message.reply_text("üîç –ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –í–≤–µ–¥–∏—Ç–µ –¥—Ä—É–≥–æ–µ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ.")
        return SEARCH
    else:
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        context.user_data['search_results'] = result.head(10).to_dict(orient="records")

        keyboard = []  # –ö–Ω–æ–ø–∫–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤

        for idx, row in enumerate(context.user_data['search_results']):
            # –ü–æ–ª—É—á–∞–µ–º –∑–∞–º–µ—Ç–∫–∏ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –ø–æ —É–Ω–∏–∫–∞–ª—å–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
            unique_id = row.get('–ö–æ–¥', '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö')
            row_notes = notes_df[notes_df['UniqueID'] == unique_id]
            result_text = format_search_result(idx, row, row_notes)

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º
            await update.message.reply_text(result_text)

            # –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            keyboard.append([str(idx + 1)])  # –ö–Ω–æ–ø–∫–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞

        # –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É "–ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫"
        keyboard.append(["–ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫"])

        # –ö–Ω–æ–ø–∫–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)

        await update.message.reply_text(
            "–í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–º–µ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è/—É–¥–∞–ª–µ–Ω–∏—è –∑–∞–º–µ—Ç–∫–∏ –∏–ª–∏ –Ω–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫.",
            reply_markup=reply_markup
        )
        return CHOOSE_RESULT


# –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
async def choose_result(update: Update, context: ContextTypes.DEFAULT_TYPE):
    selected_text = update.message.text.strip()

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞–∂–∞–ª –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å "–ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫"
    if selected_text.lower() == "–Ω–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫":
        await update.message.reply_text(
            "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ –¥–ª—è –ø–æ–∏—Å–∫–∞:",
            reply_markup=ReplyKeyboardRemove()  # –£–±–∏—Ä–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
        )
        return SEARCH

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –≤–≤–µ–¥—ë–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —á–∏—Å–ª–æ–º
    if not selected_text.isdigit():
        await update.message.reply_text(
            "–û—à–∏–±–∫–∞: –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —Ç–æ–ª—å–∫–æ –Ω–æ–º–µ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –∏–∑ —Å–ø–∏—Å–∫–∞."
        )
        return CHOOSE_RESULT

    selected_index = int(selected_text) - 1  # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤–≤–æ–¥ –≤ –∏–Ω–¥–µ–∫—Å (—Å —É—á—ë—Ç–æ–º –Ω—É–º–µ—Ä–∞—Ü–∏–∏ —Å 0)
    search_results = context.user_data.get('search_results', [])

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –≤—ã–±—Ä–∞–Ω–Ω—ã–π –Ω–æ–º–µ—Ä –≤ –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –ø—Ä–µ–¥–µ–ª–∞—Ö
    if 0 <= selected_index < len(search_results):
        context.user_data['selected_result'] = search_results[selected_index]
        unique_id = search_results[selected_index].get('–ö–æ–¥', '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö')
        notes_df = pd.read_csv(NOTES_FILE)
        related_notes = notes_df[notes_df['UniqueID'] == unique_id]

        if related_notes.empty:
            # –ï—Å–ª–∏ –∑–∞–º–µ—Ç–æ–∫ –Ω–µ—Ç, –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é
            await update.message.reply_text(
                "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –∑–∞–º–µ—Ç–∫–∏:",
                reply_markup=ReplyKeyboardRemove()
            )
            return NOTE
        else:
            # –ï—Å–ª–∏ –∑–∞–º–µ—Ç–∫–∏ –µ—Å—Ç—å, —Å–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫–∏ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∏ —É–¥–∞–ª–µ–Ω–∏—è
            keyboard = [["–î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é –∑–∞–º–µ—Ç–∫—É"]]
            for idx, _ in enumerate(related_notes.itertuples(), start=1):
                keyboard.append([f"–£–¥–∞–ª–∏—Ç—å –∑–∞–º–µ—Ç–∫—É {idx}"])

            reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)

            await update.message.reply_text(
                "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
                reply_markup=reply_markup
            )
            context.user_data['related_notes'] = related_notes
            return DELETE_NOTE
    else:
        await update.message.reply_text(
            "–û—à–∏–±–∫–∞: –Ω–æ–º–µ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –≤–Ω–µ –¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞. –í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–º–µ—Ä –∏–∑ —Å–ø–∏—Å–∫–∞."
        )
        return CHOOSE_RESULT


# –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–º–µ—Ç–∫–∏
async def delete_note(update: Update, context: ContextTypes.DEFAULT_TYPE):
    selected_text = update.message.text.strip()
    related_notes = context.user_data.get('related_notes', pd.DataFrame())

    if selected_text == "–î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é –∑–∞–º–µ—Ç–∫—É":
        # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–π –∑–∞–º–µ—Ç–∫–∏
        await update.message.reply_text(
            "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –Ω–æ–≤–æ–π –∑–∞–º–µ—Ç–∫–∏:",
            reply_markup=ReplyKeyboardRemove()
        )
        return NOTE

    if selected_text.startswith("–£–¥–∞–ª–∏—Ç—å –∑–∞–º–µ—Ç–∫—É"):
        try:
            selected_index = int(selected_text.split()[-1]) - 1
            if 0 <= selected_index < len(related_notes):
                selected_note = related_notes.iloc[selected_index]
                notes_df = pd.read_csv(NOTES_FILE)
                notes_df = notes_df[~((notes_df['UniqueID'] == selected_note['UniqueID']) &
                                      (notes_df['Note'] == selected_note['Note']))]
                notes_df.to_csv(NOTES_FILE, index=False)
                await update.message.reply_text("üóëÔ∏è –ó–∞–º–µ—Ç–∫–∞ —É–¥–∞–ª–µ–Ω–∞! –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ –ø–æ–∏—Å–∫—É.")
                return SEARCH
            else:
                raise ValueError("–ù–µ–≤–µ—Ä–Ω—ã–π –∏–Ω–¥–µ–∫—Å")
        except ValueError:
            await update.message.reply_text(
                "–û—à–∏–±–∫–∞: –Ω–æ–º–µ—Ä –∑–∞–º–µ—Ç–∫–∏ –≤–Ω–µ –¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
            )
            return DELETE_NOTE

    await update.message.reply_text(
        "–û—à–∏–±–∫–∞: –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ."
    )
    return DELETE_NOTE


# –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∑–∞–º–µ—Ç–∫–∏
async def handle_note_save(update: Update, context: ContextTypes.DEFAULT_TYPE):
    note_text = update.message.text
    user = update.effective_user.first_name
    selected_result = context.user_data.get('selected_result', {})

    unique_id = selected_result.get('–ö–æ–¥', '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö')
    magazin = selected_result.get('–ú–∞–≥–∞–∑–∏–Ω', '–ù–µ —É–∫–∞–∑–∞–Ω')

    notes_df = pd.read_csv(NOTES_FILE)

    new_note = pd.DataFrame([[user, "", unique_id, magazin, note_text]],
                            columns=["User", "Keywords", "UniqueID", "Magazin", "Note"])
    notes_df = pd.concat([notes_df, new_note], ignore_index=True)
    notes_df.to_csv(NOTES_FILE, index=False)

    await update.message.reply_text("üìù –ó–∞–º–µ—Ç–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞! –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ –ø–æ–∏—Å–∫—É.")
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ —Å–ª–æ–≤–æ –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤ —Ç–∞–±–ª–∏—Ü–µ:", reply_markup=ReplyKeyboardRemove())
    return SEARCH


# –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ–≥–æ –±–æ—Ç–∞
async def fallback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "–ë–æ—Ç –Ω–µ–∞–∫—Ç–∏–≤–µ–Ω. –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ.",
        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Start", callback_data="start")]])
    )


# –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –∫–Ω–æ–ø–∫–∏ "Start"
async def start_over(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()  # –û—Ç–≤–µ—á–∞–µ–º –Ω–∞ –Ω–∞–∂–∞—Ç–∏–µ –∫–Ω–æ–ø–∫–∏
    await query.edit_message_text(
        "–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ —Ç–∞–±–ª–∏—Ü–µ üìä\n–í–≤–µ–¥–∏—Ç–µ —Å–ª–æ–≤–æ –¥–ª—è –ø–æ–∏—Å–∫–∞ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /view_notes –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∑–∞–º–µ—Ç–æ–∫."
    )
    return SEARCH


# –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
def main():
    app = Application.builder().token(TOKEN).build()

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            SEARCH: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_search),
            ],
            CHOOSE_RESULT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, choose_result),
            ],
            NOTE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_note_save),
            ],
            DELETE_NOTE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, delete_note),
            ],
        },
        fallbacks=[MessageHandler(filters.ALL, fallback_handler)],
    )

    app.add_handler(conv_handler)
    app.add_handler(CommandHandler("view_notes", view_notes))  # –ù–æ–≤—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
    app.add_handler(CallbackQueryHandler(start_over, pattern="^start$"))

    print("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω ‚úÖ")
    app.run_polling()


if __name__ == "__main__":
    main()